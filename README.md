<p align="center"><img width="794" height="307" alt="Image" src="https://github.com/user-attachments/assets/27018eed-4c3b-4814-b588-c5e77715c6bd" /><br><br>

**사용 기술**

BE : SpringBoot, Spring Webflux, Java

FE : React.js, JavaScript

DB/Cache : MySQL, Redis

INFRA : Kafka

ETC : SSE <br><br>

### 요청 흐름

---

1. 대기열 등록 요청 ( 이때 SSE와 연결됩니다. ) <br>
이를 통해 실시간으로 변경된 순번이나 타겟 페이지 접근 권한을 전달받습니다.<br><br>

2. Redis 대기열에 사용자를 추가하고 outbox 테이블에 해당 사용자를 저장합니다. ( 상태 값 : “WAIT” )<br><br>

3. 사용자 등록, 삭제, 스케줄러에 의한 허용열 이동 등의 대기열 변동이 발생하면 Sink에 연결된 모든 사용자의 Outbox 상태 값이 변경됩니다<br><br>

4. Outbox 테이블의 변경으로 Binary Log 값이 갱신되면, Debezium 커넥터가 이를 감지하여 카프카에 이벤트를 발행하고, 해당 메시지는 컨슈머를 통해 서버에 연결된 모든 Sink로 전달합니다.<br><br>

5. 이를 통해 Redis 대기열에 있는 사용자의 경우 현재 순위를 조회해 전달하고, 허용열에 있는 사용자의 경우 ‘confirm’ 이벤트를 전달합니다.
<br>클라이언트가 이 ‘confirm’ 이벤트를 수신하면 예약 페이지로 이동합니다.<br><br>

### 구조 개선
---

만약 이벤트가 소실되어 특정 사용자가 타겟 페이지로 이동하지 못하는 상황이 발생한다면, 이는 서비스에 직접적인 영향을 줄 수 있습니다. 기존에는 Redis를 활용해 이벤트를 전송, 처리했지만, 이 방식에서는 이벤트 소실 시 재시도가 불가능한 구조라고 생각했습니다.

이러한 문제 해결을 위해 Kafka 기반의 이벤트 전송 구조로 개선하였으며, 이를 통해 이벤트 전송의 안정성을 확보하고, 전송 실패 시 재시도가 가능하도록 하였습니다.

또한, 서비스 내에서 특정 이벤트가 소실될 경우, 데이터베이스에는 변경 사항이 반영되었지만 이벤트 스트림에는 전달되지 않아 정합성이 깨질 위험이 있었습니다. 

이를 해결하기 위해 Debezium MySQL 커넥터를 활용하여 데이터베이스 테이블의 변경 사항을 감지하고 이를 Kafka 토픽으로 발행하도록 구현했습니다. 

이 방식은 데이터베이스 트랜잭션과 이벤트 발행을 연관하여 정합성 문제를 해결하도록 하였습니다.

또한, Debezium은 MySQL의 binlog를 기반으로 이벤트를 전달하기 때문에 이벤트 손실 없이 재시도가 가능하고, 변경 사항의 순서를 자연스럽게 보장할 수 있습니다.

결과적으로, Debezium 기반의 Transactional Outbox Pattern을 구현함으로써 DB와 이벤트 스트림 간의 불일치 문제를 해결하고, 이벤트 소실 방지, 순서 보장, 데이터 정합성을 처리할 수 있었습니다.<br><br>

### 추후 개선점
---
비동기 로직에서의 DB 사용은 트랜잭션 지연 및 연결 풀 고갈 등으로 병목을 유발할 수 있으므로 이를 제거하고 Kotlin 기반의 코루틴을 사용하여 경량 동시성 및 효율적인 비동기 처리를 하고자 하며, 이후 사용할 멱등성 로직 적용에서의 DB는 R2DBC를 사용하거나 블로킹 호출을 별도의 IO 디스패처로 분리하여 처리할 예정입니다  

추가적으로, 단일 서버에서 분산 서버로 확장 함으로써 부하 분산 및 고가용성을 확보할 계획입니다.
