종종 YES24나 인터파크에서 티켓을 예매하곤 했는데, 티켓 오픈 시간과 동시에 적게는 수천 명, 많게는 수만 명이 한꺼번에 몰려들었습니다. 

이때 제 대기 번호와 현재 대기자 수 등 실시간 대기 정보를 확인할 수 있었고 문득 이러한 시스템이 어떠한 구조를 가지고 있으며, 어떤 방식으로 동작하는지 궁금했습니다.

어떻게 이렇게 많은 사람들에 대한 순번과 입장을 관리할 수 있을지 ??

그리고 새로고침을 하면 어떤 방식으로 순번이 밀리는지 ??

### **요구사항**

---

접속자 대기열 시스템은 짧은 시간 안에 대량의 트래픽이 유입되는 상황에서 웹 어플리케이션의 안정적인 운영을 돕기 위해 사용되는 구조 !

이 시스템은 동시에 처리할 수 있는 요청의 수를 제한하고, 초과된 요청은 대기열 ( Queue )에 저장한 뒤순차적으로 처리함으로써 서버의 과부하를 방지

만약 대기열 시스템이 없다면 갑자기 몰리 트래픽으로 인해 서버 다운, 응답 지연, 오류가 발생하는 등의 문제가 발생할 수 있으므로 특정 시점에 수많은 사용자가 몰리는 환경에서 반드시 필요 !

**트래픽의 유형 3가지** 

1. 선형적으로 트래픽이 증가하는 경우
    
    트래픽이 천천히 증가하므로 서버 확장이나 DB 성능 조정 등으로 대응이 가능
    
2. 트래픽이 반복적으로 늘었다 줄었다 하는 경우
    
    출퇴근 시간의 대중교통 앱, 식사시간의 배달앱처럼 일정 주기에 따라 트래픽이 변동하는데, 
    
    이 경우 자동화된 스케일 인/아웃 기능을 통해 대응할 수 있음
    
3. 짧은 시간 내 급격하게 폭증하는 경우
    
    티켓팅이나 수강신청과 같은 이벤트에서는 수 초 내에 수십 배의 트래픽이 몰릴 수 있으며, 
    
    이는 일반적인 스케일 아웃으로는 대응하기 어렵고, 이 경우 대기열 시스템이 매우 효과적으로 작동
    

### 구조

---

블로킹 I/O를 지원하는 Webflux와 인메모리 데이터 저장소인 Redis를 활용하여 구현 해볼 예정

이를 통해, 동시다발적으로 유입되는 대량의 트래픽 속에서도 접속자 수를 효과적으로 제어하고 관리할 수 있는 구조를 구성

대기열 시스템이 없는 구조에서는 사용자가 웹 애플리케이션에 직접 접근하여 곧바로 타겟 페이지의 정보를 요청하고 응답을 받는 구조였지만, 접속자 대기열 시스템을 도입한 이후에는, 사용자가 먼저 대기열 페이지로 진입하여 현재 대기 인원 수나 예상 대기 시간 등의 정보를 확인한 후, 대기 순서가 되면 타겟 웹페이지로 자동으로 이동하는 방식으로 흐름이 바뀌도록 함

⇒ 서버 과부하를 방지하고, 사용자 경험을 보다 안정적으로 유지할 수 있도록 도움

**대기열에 필요한 기능**

1. 들어오는 요청을 순서대로 저장
2. 각 사용자는 자신의 순위가 몇 번인지 알 수 있어야 함
3. 대기열에 등록된 순서에 따라 요청을 차례대로 처리

**왜 대기열 자료구조로 무엇을 사용할까 ??**

접속자 대기열 시스템을 구현하는 기술 선택에서, 처음에는 Kafka, RabbitMQ, AWS SQS와 같은 대용량 메세지를 빠르고 안전하게 처리하는데 특화되어있고, 일반적으로 많이 사용하는 메세지 큐 시스템들이 자연스럽게 후보로 생각 났습니다.

하지만, 메세지 큐 시스템은 메세지를 순차적으로 처리할 수는 있지만, 특정 메세지가 큐에서 몇 번째에 있는지 알 수 없고, 사용자가 자신의 순서를 실시간으로 확인할 수 있는 구조를 지원하지 않고 구축과 운영 비용이 크기 때문에 내가 만들고자 하는 기능에는 적합하지 않으므로 다른 대안을 생각하던 도중 

Redis의  Sorted Set 자료 구조가 생각났습니다.

**Redis의  Sorted Set를 사용하는 이유**

각각의 접속을 key로 userId, value로 요청 시간으로 관리하며, 이를 통해 선착순 입장을 보장

또한 Sorted Set는 value 값을 이용하여 자동 정렬을 해주고 중복 삽입을 방지 해주며, 상위 N명을 추출하거나 제거하고, 특정 사용자의 순위를 O( logN )으로 반환하는 등의 명령어를 제공 

즉, Sorted Set을 사용하면 대기열에서 사용자의 순위를 정확하게 파악할 수 있을 뿐만 아니라, 예약 가능한 수량에 따라 상위 N명을 선별하여 예약을 확정하고, 나머지 인원은 대기 상태로 유지하거나 제거하는 로직을 손쉽게 구현할 수 있음
