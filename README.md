### **요구사항**
---

종종 YES24나 인터파크에서 티켓을 예매하곤 했는데, 티켓 오픈 시간과 동시에 적게는 수천 명, 많게는 수만 명이 한꺼번에 몰려들었습니다. 

이때 제 대기 번호와 현재 대기자 수 등 실시간 대기 정보를 확인할 수 있었고 문득 이러한 시스템이 어떠한 구조를 가지고 있으며, 어떤 방식으로 동작하는지 궁금했습니다.

어떻게 이렇게 많은 사람들에 대한 순번과 입장을 관리할 수 있을지 ??

그리고 새로고침을 하면 어떤 방식으로 순번이 밀리는지 ??

### **요구사항**
---

접속자 대기열 시스템은 짧은 시간 안에 대량의 트래픽이 유입되는 상황에서 웹 어플리케이션의 안정적인 운영을 돕기 위해 사용되는 구조 !

이 시스템은 동시에 처리할 수 있는 요청의 수를 제한하고, 초과된 요청은 대기열 ( Queue )에 저장한 뒤순차적으로 처리함으로써 서버의 과부하를 방지

만약 대기열 시스템이 없다면 갑자기 몰리 트래픽으로 인해 서버 다운, 응답 지연, 오류가 발생하는 등의 문제가 발생할 수 있으므로 특정 시점에 수많은 사용자가 몰리는 환경에서 반드시 필요 !<br><br><br>

**트래픽의 유형 3가지** 

1. 선형적으로 트래픽이 증가하는 경우
    
    트래픽이 천천히 증가하므로 서버 확장이나 DB 성능 조정 등으로 대응이 가능
    
2. 트래픽이 반복적으로 늘었다 줄었다 하는 경우
    
    출퇴근 시간의 대중교통 앱, 식사시간의 배달앱처럼 일정 주기에 따라 트래픽이 변동하는데, 
    
    이 경우 자동화된 스케일 인/아웃 기능을 통해 대응할 수 있음
    
3. 짧은 시간 내 급격하게 폭증하는 경우
    
    티켓팅이나 수강신청과 같은 이벤트에서는 수 초 내에 수십 배의 트래픽이 몰릴 수 있으며, 
    
    이는 일반적인 스케일 아웃으로는 대응하기 어렵고, 이 경우 대기열 시스템이 매우 효과적으로 작동<br>
    

### 구조
---

블로킹 I/O를 지원하는 Webflux와 인메모리 데이터 저장소인 Redis를 활용하여 구현 해볼 예정

이를 통해, 동시다발적으로 유입되는 대량의 트래픽 속에서도 접속자 수를 효과적으로 제어하고 관리할 수 있는 구조를 구성

대기열 시스템이 없는 구조에서는 사용자가 웹 애플리케이션에 직접 접근하여 곧바로 타겟 페이지의 정보를 요청하고 응답을 받는 구조였지만, 접속자 대기열 시스템을 도입한 이후에는, 사용자가 먼저 대기열 페이지로 진입하여 현재 대기 인원 수나 예상 대기 시간 등의 정보를 확인한 후, 대기 순서가 되면 타겟 웹페이지로 자동으로 이동하는 방식으로 흐름이 바뀌도록 함

⇒ 서버 과부하를 방지하고, 사용자 경험을 보다 안정적으로 유지할 수 있도록 도움<br>

**대기열에 필요한 기능**

1. 들어오는 요청을 순서대로 저장
2. 각 사용자는 자신의 순위가 몇 번인지 알 수 있어야 함
3. 대기열에 등록된 순서에 따라 요청을 차례대로 처리<br>

**왜 대기열 자료구조로 무엇을 사용할까 ??**

접속자 대기열 시스템을 구현하는 기술 선택에서, 처음에는 Kafka, RabbitMQ, AWS SQS와 같은 대용량 메세지를 빠르고 안전하게 처리하는데 특화되어있고, 일반적으로 많이 사용하는 메세지 큐 시스템들이 자연스럽게 후보로 생각 났습니다.

하지만, 메세지 큐 시스템은 메세지를 순차적으로 처리할 수는 있지만, 특정 메세지가 큐에서 몇 번째에 있는지 알 수 없고, 사용자가 자신의 순서를 실시간으로 확인할 수 있는 구조를 지원하지 않고 구축과 운영 비용이 크기 때문에 내가 만들고자 하는 기능에는 적합하지 않으므로 다른 대안을 생각하던 도중 

Redis의  Sorted Set 자료 구조가 생각났습니다.<br>

**Redis의  Sorted Set를 사용하는 이유**

각각의 접속을 key로 userId, value로 요청 시간으로 관리하며, 이를 통해 선착순 입장을 보장

또한 Sorted Set는 value 값을 이용하여 자동 정렬을 해주고 중복 삽입을 방지 해주며, 상위 N명을 추출하거나 제거하고, 특정 사용자의 순위를 O( logN )으로 반환하는 등의 명령어를 제공 

즉, Sorted Set을 사용하면 대기열에서 사용자의 순위를 정확하게 파악할 수 있을 뿐만 아니라, 예약 가능한 수량에 따라 상위 N명을 선별하여 예약을 확정하고, 나머지 인원은 대기 상태로 유지하거나 제거하는 로직을 손쉽게 구현할 수 있음<br>

**실시간 정보 제공 방법**

대기열에 있는 사용자의 대기 순번이 바뀌었을 때, 사용자에게 이를 어떻게 알려줄까 ??

티켓팅 대기열 같은 경우 실시간으로 순위가 바뀌고, 이를 사용자에게 실시간으로 표시해주는 것이 가장 중요한데 이를 위한 통신 방법들이 존재<br>

1. Polling
    
    클라이언트가 주기적으로 서버에 데이터를 요청해서 변화가 있는지를 확인하는 방식
    
    구현 난이도가 간단하지만, 불필요한 요청이 많게 되므로 서버의 부하를 줄 수 있음
    
2. Long Polling
    
    일반 Polling의 비효율을 개선한 방식으로 클라이언트가 서브에 요청을 보낸 뒤, 서버에 새 데이터가 생길 때까지 응답을 늦추는 방식
    
    ⇒ 데이터가 생기면 응답을 반환하고, 일정 시간이 지나도 변화가 없다면 타임아웃 응답
    
    ⇒ 클라이언트는 응답을 받자마자 다시 요청 ( 반복 )
    
    하지만, 연결 유지 비용이 크기 때문에 서버 리소스 사용량이 증가하기에 이를 관리하기 어려움
    

3. SSE ( Server-Sent-Events )
    
    서버가 클라이언트에 단방향으로 실시간 데이터를 푸시할 수 있도록 해주는 HTTP 기반 통신 방식
    
    클라이언트가 서버에 한 번 연결하면, 서버가 지속적으로 데이터를 전송 가능
    
    - 단방향 통신 ( 서버 → 클라이언트 ) → 단점이 될 수 있음

4. 웹 소켓
    
    양방향 실시간 통신을 가능하게 해주는 프로토콜로, 브라우저와 서버 사이에서 지속적인 연결을 유지하며 데이터를 주고받을 수 있음
    
    - 초기는 HTTP로 연결을 시작하지만, Handshake 이후에는 TCP 기반의 전이중통신으로 전환
    - 클라이언트와 서버 간에 지속적으로 연결 유지
    - 실시간 채팅, 게임, 알림 등에 자주 사용됨

    핸드셰이크 비용이 존재하고, 구현이 복잡

따라서 어떤 방식을 선택하는 것이 가장 좋을까 생각을 해보니 당연히 웹 소켓을 사용하는것이 최고의 선택이지만 웹 소켓은 이미 다뤄보았기 때문에 경험해보지 못했던 Polling 방식이나 SSE 방식을 사용해볼까 합니다.
