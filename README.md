### **요구사항**
---

종종 YES24나 인터파크에서 티켓을 예매하곤 했는데, 티켓 오픈 시간과 동시에 적게는 수천 명, 많게는 수만 명이 한꺼번에 몰려들었습니다. 

이때 제 대기 번호와 현재 대기자 수 등 실시간 대기 정보를 확인할 수 있었고 문득 이러한 시스템이 어떠한 구조를 가지고 있으며, 어떤 방식으로 동작하는지 궁금했습니다.

어떻게 많은 사람들에 대한 순번과 입장을 관리할 수 있을지 ??

### **요구사항**
---

접속자 대기열 시스템은 짧은 시간 안에 대량의 트래픽이 유입되는 상황에서 웹 어플리케이션의 안정적인 운영을 돕기 위해 사용되는 구조 !

이 시스템은 동시에 처리할 수 있는 요청의 수를 제한하고, 초과된 요청은 대기열 ( Queue )에 저장한 뒤순차적으로 처리함으로써 서버의 과부하를 방지

만약 대기열 시스템이 없다면 갑자기 몰리 트래픽으로 인해 서버 다운, 응답 지연, 오류가 발생하는 등의 문제가 발생할 수 있으므로 특정 시점에 수많은 사용자가 몰리는 환경에서 반드시 필요 !<br><br>

**트래픽의 유형 3가지** 

1. 선형적으로 트래픽이 증가하는 경우
    
    트래픽이 천천히 증가하므로 서버 확장이나 DB 성능 조정 등으로 대응이 가능
    
2. 트래픽이 반복적으로 늘었다 줄었다 하는 경우
    
    출퇴근 시간의 대중교통 앱, 식사시간의 배달앱처럼 일정 주기에 따라 트래픽이 변동하는데, 
    
    이 경우 자동화된 스케일 인/아웃 기능을 통해 대응할 수 있음
    
3. 짧은 시간 내 급격하게 폭증하는 경우
    
    티켓팅이나 수강신청과 같은 이벤트에서는 수 초 내에 수십 배의 트래픽이 몰릴 수 있으며, 
    
    이는 일반적인 스케일 아웃으로는 대응하기 어렵고, 이 경우 대기열 시스템이 매우 효과적으로 작동<br><br>
    

### 구조
---

블로킹 I/O를 지원하는 Webflux와 인메모리 데이터 저장소인 Redis를 활용하여 구현 해볼 예정

이를 통해, 동시다발적으로 유입되는 대량의 트래픽 속에서도 접속자 수를 효과적으로 제어하고 관리할 수 있는 구조를 구성

대기열 시스템이 없는 구조에서는 사용자가 웹 애플리케이션에 직접 접근하여 곧바로 타겟 페이지의 정보를 요청하고 응답을 받는 구조였지만, 접속자 대기열 시스템을 도입한 이후에는, 사용자가 먼저 대기열 페이지로 진입하여 현재 대기 인원 수나 예상 대기 시간 등의 정보를 확인한 후, 대기 순서가 되면 타겟 웹페이지로 자동으로 이동하는 방식으로 흐름이 바뀌도록 함

⇒ 서버 과부하를 방지하고, 사용자 경험을 보다 안정적으로 유지할 수 있도록 도움<br><br>

**대기열에 필요한 기능**

1. 들어오는 요청을 순서대로 저장
2. 각 사용자는 자신의 순위가 몇 번인지 알 수 있어야 함
3. 대기열에 등록된 순서에 따라 요청을 차례대로 처리<br><br>

**왜 대기열 자료구조로 무엇을 사용할까 ??**

접속자 대기열 시스템을 구현하는 기술 선택에서, 처음에는 Kafka, RabbitMQ, AWS SQS와 같은 대용량 메세지를 빠르고 안전하게 처리하는데 특화되어있고, 일반적으로 많이 사용하는 메세지 큐 시스템들이 자연스럽게 후보로 생각 났습니다.

하지만, 메세지 큐 시스템은 메세지를 순차적으로 처리할 수는 있지만, 특정 메세지가 큐에서 몇 번째에 있는지 알 수 없고, 사용자가 자신의 순서를 실시간으로 확인할 수 있는 구조를 지원하지 않고 구축과 운영 비용이 크기 때문에 내가 만들고자 하는 기능에는 적합하지 않으므로 다른 대안을 생각하던 도중 

Redis의  Sorted Set 자료 구조가 생각났습니다.<br><br>

**Redis의  Sorted Set를 사용하는 이유**

각각의 접속을 key로 userId, value로 요청 시간으로 관리하며, 이를 통해 선착순 입장을 보장

또한 Sorted Set는 value 값을 이용하여 자동 정렬을 해주고 중복 삽입을 방지 해주며, 상위 N명을 추출하거나 제거하고, 특정 사용자의 순위를 O( logN )으로 반환하는 등의 명령어를 제공 

즉, Sorted Set을 사용하면 대기열에서 사용자의 순위를 정확하게 파악할 수 있을 뿐만 아니라, 예약 가능한 수량에 따라 상위 N명을 선별하여 예약을 확정하고, 나머지 인원은 대기 상태로 유지하거나 제거하는 로직을 손쉽게 구현할 수 있음<br><br>

**실시간 정보 제공 방법**

대기열에 있는 사용자의 대기 순번이 바뀌었을 때, 사용자에게 이를 어떻게 알려줄까 ??

티켓팅 대기열 같은 경우 실시간으로 순위가 바뀌고, 이를 사용자에게 실시간으로 표시해주는 것이 가장 중요한데 이를 위한 통신 방법들이 존재<br><br>

1. Polling
    
    클라이언트가 주기적으로 서버에 데이터를 요청해서 변화가 있는지를 확인하는 방식
    
    구현 난이도가 간단하지만, 불필요한 요청이 많게 되므로 서버의 부하를 줄 수 있음
    
2. Long Polling
    
    일반 Polling의 비효율을 개선한 방식으로 클라이언트가 서브에 요청을 보낸 뒤, 서버에 새 데이터가 생길 때까지 응답을 늦추는 방식
    
    ⇒ 데이터가 생기면 응답을 반환하고, 일정 시간이 지나도 변화가 없다면 타임아웃 응답
    
    ⇒ 클라이언트는 응답을 받자마자 다시 요청 ( 반복 )
    
    하지만, 연결 유지 비용이 크기 때문에 서버 리소스 사용량이 증가하기에 이를 관리하기 어려움
    

3. SSE ( Server-Sent-Events )
    
    서버가 클라이언트에 단방향으로 실시간 데이터를 푸시할 수 있도록 해주는 HTTP 기반 통신 방식
    
    클라이언트가 서버에 한 번 연결하면, 서버가 지속적으로 데이터를 전송 가능
    
    - 단방향 통신 ( 서버 → 클라이언트 ) → 단점이 될 수 있음

4. 웹 소켓
    
    양방향 실시간 통신을 가능하게 해주는 프로토콜로, 브라우저와 서버 사이에서 지속적인 연결을 유지하며 데이터를 주고받을 수 있음
    
    - 초기는 HTTP로 연결을 시작하지만, Handshake 이후에는 TCP 기반의 전이중통신으로 전환
    - 클라이언트와 서버 간에 지속적으로 연결 유지
    - 실시간 채팅, 게임, 알림 등에 자주 사용됨

    핸드셰이크 비용이 존재하고, 구현이 복잡

따라서 어떤 방식을 선택하는 것이 가장 좋을까 생각을 해보니 당연히 웹 소켓을 사용하는것이 최고의 선택이지만 웹 소켓은 이미 다뤄보았기 때문에 경험해보지 못했던 Polling 방식이나 SSE 방식을 사용해볼까 합니다. <br><br>

이번에 대기열 시스템을 구현해보는 과정에서 많은 사람들의 요청이 동시에 들어오는 상황을 가정하게 되었고, 

이에 따라 어떻게 하면 빠르게 응답을 하며 스레드를 효율적으로 관리할 수 있을까에 대한 고민이 생겼습니다

이러한 고민 끝에 webFlux가 떠오르게 되었고, 이를 기반으로 프로젝트를 진행해보았습니다.<br><br>

### webFlux

---

Spring Framework의 기술 스택 중 하나로, 리액티브 프로그래밍을 지원하여 Asynchronous Non-blocking와 Event-Driven 아키텍처를 기반으로 동작하는 프레임워크

> `Event-Driven` 이벤트 기반 구조 : 이벤트가 발생했을 때 반응하여 동작하는 시스템 구조
> 

> `Asynchronous Non-blocking I/O`을 사용하여 I/O 작업의 완료를 기다리는 동안에도 다른 작업을 동시에 처리하여 리소스를 효율적으로 사용할 수 있도록 함
> 

기존의 Spring MVC는 각 요청마다 하나의 스레드를 사용하지만, 이런 방식은 동시 접속자가 많을수록 스레드가 고갈

되고 성능이 떨어질 수 있지만, webFlux와 기반 도구인 Reactor를 사용한다면 여러 요청이 들어오더라도 블로킹 없이 

처리할 수 있으며, 이벤트가 발생했을 때 필요한 작업만 수행하고, I/O 대기 시간동안 다른 작업을 병렬로 처리할 수 있기

에 적은 자원으로 많은 요청을 효율적으로 처리할 수 있습니다.<br><br>

**Reactor란**

Java JVM 위에서 동작하는 Non-Blocking 리액티브 프로그래밍을 위한 라이브러리로 Reactive Stream의 구현체

Reactive Stream의 publish 인터페이스를 구현한 리액티브 타입인 Mono와 Flux를 제공

- Mono : 0개 또는 1개의 데이터를 비동기적으로 처리
- Flux : 0개 이상의 데이터 스트림은 비동기적으로 처리<br><br>

### 흐름 구성

---

- 사용자가 이름을 입력한 후 `예약하기` 버튼을 누르면, 클라이언트는 해당 정보를 서버로 전송
- 서버는 사용자의 요청을 받아, 사용자가 입장한 시간을 기준으로 사용자 정보를 Redis의 Sorted Set에 저장하며, 이를 통해 대기 큐가 자동으로 정렬되도록 구성
- 등록을 하게 되면 클라이언트는 SSE를 통해 서버와 연결을 유지하면서, 실시간으로 자신의 대기 상태나 순번이 변경되는 정보를 전달받게 됨
- 서버에서는 별도로 설정된 스케줄러가 주기적으로 동작 하면서, 대기 큐에 있는 사용자들 중 상위 N명을 꺼내어 허용 큐로 이동시키고, 이 허용 큐로 이동한 사용자는 타겟 페이지로 이동할 수 있는 권한을 가짐
- 허용 큐에 진입한 사용자에게는 서버가 고유 토큰을 생성하여 응답에 포함시켜 클라이언트의 cookie에 저장하고 타겟 페이지로 이동
- 사용자가 해당 타겟 페이지에 접근하면, 서버는 클라이언트가 보낸 토큰과 동일한 방식으로 내부에서 토큰을 다시 생성하거나 비교하여, 쿠키에 포함된 토큰과 정확히 일치하는지 검증
- 토큰이 서버의 검증을 통과하면, 사용자는 해당 타겟 페이지에 최종적으로 접근할 수 있게 되며, 유효하지 않거나 없는 경우에는 접근이 차단
- 타겟 페이지에 이동했을 때 유효 시간을 10분으로 타이머가 진행되며 시간이 종료될 경우 자동으로 예약 등록 페이지로 이동<br><br>

### 구현

---

**사용 기술**

BE : SpringBoot, Spring Webflux

FE : React.js, JavaScript

DB : Redis sorted set

Etc : sse
